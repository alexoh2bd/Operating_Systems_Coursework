In this exercise, we write a dtrace program which probes the vm_fault_trap kernel method. vm_fault_trap handles page faults, so Dtrace tracks all the page faults and returns whether it was handled correctly (0) or not (1). As we can see, from c program, I create a page fault that cannot be handled correctly. I set a pointer to address 0, and try to write a string to that pointer. Thus, in the sample output, we see a few page faults created naturally from the program on CPU 1 which are handled correctly as they return 0. In the middle of the output, there is a page fault on CPU 2 with  virtual address 0000 which returns 1. The return value of 1 indicates that the page fault was not handled correctly and the virtual address 0000 indicates that this was the page fault we created at pointer 0. 

When a kernel allocates memory to a process, the process is given a range of virtual addresses which are allocated to the process without necessarily any physical addresses mapped: this mapping would be an inefficient use of physical memory. When the process wants to act upon these virtual addresses, a page fault is called. The kernel checks the page table, notices the lack of physical address mappings, finds an available page in physical, and copies the data into that page. Every time a process needs new access to physical memory, a page fault is called to map virtual memory to physical. The page faults returning 0 shown in the sample output are examples of the process naturally and correctly accesing new physical memory through the kernel. 
